#!/bin/bash
# stolen from https://gist.github.com/roberd13/c2c3786380c6fb3c2860a3ac13d019f4
# Use this script to run the same command across multiple hosts.
# You must have passwordless ssh enabled
# You need to create hostnames.txt file with the hosts you want to run the commands on
# Usage Example ./runcommand.sh "service network restart"

# NOTE difference between ${ar[*]} and ${ar[@]}
# https://unix.stackexchange.com/a/135011

# NOTE if outputs from different servers interven,
# https://unix.stackexchange.com/a/476089

# TODO --get ???

# TODO usage documentation with examples

OPT_HOSTS=()

while [[ $# -gt 0 ]]; do
	case $1 in
		-v|--verbose)
			OPT_VERBOSE='-v'
			shift ;;
		-n|--dry-run)
			OPT_DRY='yes'
			shift ;;
		-h|--hostfile)
			OPT_HOSTFILE="$2"
			shift; shift ;;
		-s|--sudo)
			OPT_SUDO="$2"
			shift; shift ;;
		--put)
			OPT_PUT='yes'
			shift ;;
		--) # end of flags
			shift; break ;;
		-*|--*)
			echo "unknown option; '$1' ignoring... "
			exit 1 ;;
		*)
			OPT_HOSTS+=($1) # NOTE whitespace splits the hostname!
			shift ;;
	esac
done


############################
## process host list

HOSTS=("${OPT_HOSTS[@]}")

if [ -n "$OPT_HOSTFILE" ]; then
	readarray -t OPT_HOSTS_F < "$OPT_HOSTFILE" # FIXME only delimited by newline; element might contain whitespace :(
	if [ $? -ne 0 ]; then exit 2; fi
	HOSTS+=("${OPT_HOSTS_F[@]}")
fi

# leave only uniq hostnames; don't need IFS re-setting since all elems should not contain whitespace anyways
# https://stackoverflow.com/a/13648438
HOSTS=($(printf "%s\n" "${HOSTS[@]}" | sort -u | tr '\n' ' '))

# TODO check if all hosts are available https://superuser.com/a/1465650
# TODO option to ignore failed hosts ?
# TODO /etc/host change needed beforehand, or ssh hostname resolve needed


############################
## process following arguments

if [ -z "$OPT_PUT" ]; then
	# remote command

	COMMANDS=()

	if [ -n "$OPT_VERBOSE" ]; then
		COMMANDS+=("set -x;")
	fi

	COMMANDS+=("$@")

	COMMAND="${COMMANDS[*]}"

else
	# copying files
	SRCS=("$@")
	if [ ${#SRCS[@]} -lt 2 ]; then
		echo "should specify at least one SRC and a DST"
		exit 3;
	fi

	DST="${SRCS[-1]}"
	unset SRCS[${#SRCS[@]}-1]
fi


############################
## end of arg processing

YELLOW="`tput setaf 3`"
NC="`tput sgr0`"

# TODO no color option?

#if [ -n "$OPT_VERBOSE" ]; then
	if [ -z "$OPT_PUT" ]; then
		printf "$YELLOW :: RUNNING COMMAND$NC '%s'\n" "$COMMAND"
		printf "$YELLOW :: ON HOSTS$NC %s\n" "${HOSTS[*]}"
	else
		printf "$YELLOW :: SENDING FILE(S)$NC %s\n" "${SRCS[*]}"
		printf "$YELLOW :: TO$NC '%q'$YELLOW ON HOSTS$NC %s\n" "$DST" "${HOSTS[*]}"
	fi

	if [ -n "$OPT_SUDO" ]; then
		printf "$YELLOW :: WITH SUDO PREVILEGE$NC\n"
	fi
#fi


############################
## body of execution

execute_body() {
	# TODO color stderr??

	#for host in `grep -Poe "Host \K\S+" ~/.ssh/config | tail -n+2`; do
	for host in "${HOSTS[@]}"; do
		# TODO adaptive pad-width setting
		host_rep="`printf '[%8s]' $host`"
		if [ -n "$OPT_SUDO" ]; then
			# https://stackoverflow.com/a/39710432
			# for some reason, sudo -p option ignores given argument when its empty; so we use terminal bell (\x07)
			# to make it nonempty while not showing anything on the screen
			ssh $host "sudo -p '' -S bash" "-c '$COMMAND'" < <(echo "$OPT_SUDO") 2>&1 | sed "s/^/$host_rep /" &
		else
			# TODO what if output is totally empty?
			ssh $host "bash" "-c '$COMMAND'" </dev/null 2>&1 | sed "s/^/$host_rep /" &
		fi
	done

	wait
}

copy_body() {
	#for host in `grep -Poe "Host \K\S+" ~/.ssh/config | tail -n+2`; do
	for host in "${HOSTS[@]}"; do
		if [ -n "$OPT_SUDO" ]; then
			# https://stackoverflow.com/a/39710432
			# for some reason, sudo -p option ignores given argument when its empty; so we use terminal bell (\x07)
			# to make it nonempty while not showing anything on the screen
			#ssh $host "sudo -p '' -S bash" "-c '$COMMAND'" < <(echo "$OPT_SUDO") 2>&1 | sed "s/^/[$host] /"
			# TODO
			echo ha
		else
			# TODO elaborate reporing...
			scp -q "${SRCS[@]}" $host:$DST && echo sending to $host finished &
		fi
	done

	wait
}

if [ -n "$OPT_DRY" ]; then
	exit 0;
fi

stdbuf -oL

if [ -z "$OPT_PUT" ]; then
	execute_body
else
	copy_body
fi
